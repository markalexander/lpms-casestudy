!@encoding CP1252
model EPower
uses "mmxprs";
uses "mmsystem";

!
! DECLARE PARAMETERS
!

parameters
	! Report/output generation settings
	ReportOptGenSched = true     ! Report optimal generation schedules?
	ReportEmissions = true       ! Report emissions information?
	ReportOutputCSV = true       ! Create CSV files for reports?
	ReportOutputDir = 'output/'  ! Output directory for the CSV files
	ReportMaxWidth = 100         ! Maximum width for console output
end-parameters

!
! DECLARE MODEL IDENTIFIERS
!

declarations
	
	Source:                   set of string
	Emiss:                    set of string
	
	! Times/periods/demand
	Times:                    set of integer	
	PeriodLength:             array(Times) of real
	Demand:                   array(Times) of real
	
	! Source properties
	MaxOutput:                array(Source) of real
	RunningCost:              array(Source) of real
	IncreaseCost:             array(Source) of real
	
	! Emissions
	Emissions:                array(Emiss,Source) of real
	EmissionsLimit:           array(Emiss) of real
	
	! Misc constants
	MaxHydroReserve:          real
	NaturalHydroInflow:       real
	HydroPowerEfficiencyFrac: real
	ElectricityPrice:         real
	
	! Demand/wind multipliers for secondary analysis (group-specific)
	DemandMu:                 real
	WindMu:                   real
	
	! Additional modelling values
	EmissionsCreditPrice:     array(Emiss) of real
	
	! Decision variables
	Generate:                 array(Source,Times) of mpvar  ! Energy output from source s at time t (MW)
	Pump:                     array(Times) of mpvar  ! Energy pumped to reservoir at time t (MW)
	HydroReserve:             array(Times) of mpvar  ! Water remaining in reservoir at end of time t (MWh)
	Increase:                 array(Source,Times) of mpvar  ! Increase from source s at time t
	
end-declarations


!
! DECLARE FUNCTIONS AND PROCEDURES
!

! Get the index of the 'previous' time period for given current time period t.
! Uses modular arithmetic to find the previous time period, looping around to the start
! when given the end period.  This way we can freely extend the number of time periods
! in the .dat file without changing the main model code. I.e. this is better style.
! N.B. the in-built 'mod' operator is actually a 'remainder' operator and doesn't work
! correctly with negative numbers.  Hence the explicit definition.
function getprevperiod(t:integer):integer
	n := getsize(Times)
	returned := ((((t-2) mod n) + n) mod n) + 1
end-function

! Print a simple heading
procedure print_heading(title:string, uchar:string)
	writeln("\n", title, "\n", uchar*getsize(title), "\n")
end-procedure

! Print a standard table output for the main model.
! Saves us repeating this code for every variation of the model.
procedure generate_report(title:string, tag:string)

	writeln("\n\n")
	print_heading("SCENARIO: " + title, "#")

	!
	! Basic information
	!
	
	print_heading("BASIC INFORMATION", "=")
	writeln("Total profit: £", strfmt(getobjval/1e6, 0, 3), " million.\n")
	
	!
	! Optimal generation schedule
	!
	
	if ReportOptGenSched then
		print_heading("OPTIMAL GENERATION SCHEDULE", "=")
		
		ColWidth := round(ReportMaxWidth/7)
		writeln("-"*ReportMaxWidth)
		write(strfmt(" ", ColWidth))
		forall(t in Times) write(strfmt(t, ColWidth))
		writeln
		writeln("-"*ReportMaxWidth)
		forall(s in Source) do
			write(strfmt(s, ColWidth))
			forall(t in Times) write(strfmt(getsol(Generate(s,t)), ColWidth))
			writeln
		end-do 
		
		!writeln("-"*ReportMaxWidth)
		!write(strfmt("TOTAL", ColWidth))
		!forall(t in Times) write(strfmt(getsol(EnergySold(t)), ColWidth))
		!writeln
		
		writeln("."*ReportMaxWidth)
		write(strfmt("Reservoir lvl", ColWidth))
		forall(t in Times) write(strfmt(getsol(HydroReserve(t)), ColWidth))
		writeln
		writeln("-"*ReportMaxWidth)
		
		! Output a standard CSV file for the model
		if ReportOutputCSV then
			makedir(ReportOutputDir)
			fopen(ReportOutputDir + tag + '.csv', F_OUTPUT)
			! Headers
			write('Period,StartTime,EndTime')
			forall(s in Source) do
				write(',', s)
			end-do
			writeln
			! Data
			currtime := 0.0
			forall(t in Times) do
				starttime := currtime
				currtime += PeriodLength(t)
				endtime := currtime
				write(t, ',', starttime, ',', endtime)
				forall(s in Source) do
					write(',', getsol(Generate(s,t)))
				end-do
				writeln
			end-do
			fclose(F_OUTPUT)
		end-if
	end-if
	
	!
	! Emissions reporting
	!
	
	!if ReportEmissions then
		!writeln
		!print_heading("EMISSIONS LIMITS", "=")
		!ColWidth := round(ReportMaxWidth/4)
		!writeln("-"*ReportMaxWidth)
		!write(strfmt("Emittant", ColWidth))
		!write(strfmt("Limit", ColWidth))
		!write(strfmt("Current", ColWidth))
		!write(strfmt("Fair Price", ColWidth))
		!writeln
		!writeln("-"*ReportMaxWidth)
		!forall(e in Emiss) do
		!	write(strfmt(e, ColWidth))
		!	write(strfmt(EmissionsLimit(e), ColWidth))
		!	write(strfmt(getsol(EmissionsGenerated(e)), ColWidth))
		!	write(strfmt(getdual(EmmissionCS(e)), ColWidth))
		!	writeln
		!end-do
		!writeln("-"*ReportMaxWidth)
	!end-if
	
end-procedure

procedure initialize_data
	initializations from "EPower.dat"
		Emiss Source Times PeriodLength Demand
		MaxOutput RunningCost IncreaseCost
		Emissions EmissionsLimit
		MaxHydroReserve NaturalHydroInflow HydroPowerEfficiencyFrac ElectricityPrice
		DemandMu WindMu
		EmissionsCreditPrice
	end-initializations
end-procedure


!
! LOAD DATA FROM FILE
!

initialize_data


!
! BUILD BASIC MODEL
!

forall(t in Times) do
	! Energy sold must meet the demand exactly
	EnergySold(t) := sum(s in Source) Generate(s,t) - Pump(t)
	DemandCS(t) := EnergySold(t) = Demand(t)
	
	! Hydro reserve must not exceed maximum
	HydroReserveCS(t) := HydroReserve(t) <= MaxHydroReserve
	
	! Pumping capacity must not exceed maximum (see FAQ)
	PumpCS(t) := Pump(t) <= MaxOutput("Hydro")
	
	! Hydro reserve must be consistent across time periods
	NetHydroFlow(t) := (HydroPowerEfficiencyFrac * Pump(t) + NaturalHydroInflow - Generate("Hydro",t)) * PeriodLength(t)
	HydroReserve(t) = HydroReserve(getprevperiod(t)) + NetHydroFlow(t)
end-do

forall(s in Source) do
	! Output generation level of source at t must not exceed max output
	forall(t in Times) OutputCS(s,t) := Generate(s,t) <= MaxOutput(s)
	
	! Total energy generated from each source in MWh
	TotalEnergyGenerated(s) := sum(t in Times) Generate(s,t) * PeriodLength(t)
end-do

! Emissions must not exceed limit
forall(e in Emiss) do
	EmissionsGenerated(e) := sum(s in Source) TotalEnergyGenerated(s) * Emissions(e,s)
	EmmissionCS(e) := EmissionsGenerated(e) <= EmissionsLimit(e)
end-do

! Generation must be consistent with previous increase
forall(s in Source, t in Times) do
	IncreaseCS(s,t) := Generate(s,t) <= Generate(s,getprevperiod(t)) + Increase(s,t)
end-do	

! Objective
TotalIncreaseCost := sum(s in Source, t in Times) Increase(s,t) * IncreaseCost(s)
TotalRunningCost := sum(s in Source) TotalEnergyGenerated(s) * RunningCost(s)
TotalRevenue := sum(t in Times) EnergySold(t) * PeriodLength(t) * ElectricityPrice
TotalProfit := TotalRevenue - TotalRunningCost - TotalIncreaseCost


!
! SCENARIO: BASE CASE
!

maximize(TotalProfit)
generate_report("BASE CASE", 'base')

! Store generation schedule as long term plan
forall(s in Source, t in Times) do
	LongTermPlan(s,t) := getsol(Generate(s,t))
	LongTermPlanReservoire(t) := getsol(HydroReserve(t))
end-do


!
! SCENARIO: REDUCED CO2 EMISSION LIMIT
!

TotalCO2Emmission := sum(s in Source) TotalEnergyGenerated(s) * Emissions("CO2",s)
EmmissionCS("CO2") := sum(s in Source) TotalEnergyGenerated(s) * Emissions("CO2",s) <= EmissionsLimit("CO2") * 0.5
maximize(TotalProfit)
generate_report("STRICTER CO2 LIMITS", 'co2')


! Source expansion
print_heading("SOURCE EXPANSION DECISION", "=")

writeln("-"*ReportMaxWidth)
write(strfmt("Expand:", 13), strfmt("Profit (£m)", 13))
forall(s in Source) write(strfmt(s, 10))
write(strfmt("CO2", 10))
writeln
writeln("-"*ReportMaxWidth)

forall(s in Source) do
	
	if s = "Wind" then 
		! Company is about to finish instalation of wind capacity (see FAQ)
		MaxOutput("Wind") :=  MaxOutput("Wind") + 500 
	else
		! Increase the max output of this source by 1 GW
		MaxOutput(s) := MaxOutput(s) + 1000
	end-if
	
	! Additional increases for hydro
	if s = "Hydro" then 
		NaturalHydroInflow := NaturalHydroInflow * 1.5
		MaxHydroReserve := MaxHydroReserve * 1.5
	end-if
	
	! Fix constraints
	forall(so in Source, t in Times) do
		HydroReserveCS(t) := HydroReserve(t) <= MaxHydroReserve
		OutputCS(so,t) := Generate(so,t) <= MaxOutput(so)
		PumpCS(t) := Pump(t) <= MaxOutput("Hydro")
	end-do
	
	! Reoptimize
	maximize(TotalProfit)
	
	! Output
	write(strfmt(s, 13), "      ", strfmt(getobjval/1e6, 0, 3))
	forall(so in Source) write(strfmt(getsol(TotalEnergyGenerated(so)), 10))
	write("|", getsol(TotalCO2Emmission))
	writeln
	
	! Reset data for re-use
	initialize_data
end-do

EmmissionCS("CO2") := sum(s in Source) TotalEnergyGenerated(s)*Emissions("CO2",s)<=EmissionsLimit("CO2")
forall(s in Source, t in Times) do
	HydroReserveCS(t) := HydroReserve(t) <= MaxHydroReserve
	OutputCS(s,t) := Generate(s,t) <= MaxOutput(s)
	PumpCS(t) := Pump(t) <= MaxOutput("Hydro")
end-do


!
! SCENARIO: VARIABLE DEMAND/WIND AVAIL.
!

! The values for nuclear, coal and gas in last period need to be consistent with
! the long term plan. 
forall(s in Source) do
	if s = "Nuclear" or s = "Coal" or s = "Gas" then
		LongTermCS(s) := Generate(s,getprevperiod(1)) = LongTermPlan(s,getprevperiod(1))
	end-if
end-do

! Amount of water stored in reservouir in last period need to be consisten with long term plan
LongTermReservoireCS := HydroReserve(getprevperiod(1)) = LongTermPlanReservoire(getprevperiod(1))

	
MaxOutput("Wind") := MaxOutput("Wind") * WindMu
forall(t in Times) do
	OutputCS("Wind",t) := Generate("Wind",t) <= MaxOutput("Wind")
	Demand(t) := Demand(t) * DemandMu
	DemandCS(t) := EnergySold(t) = Demand(t)
end-do

maximize(TotalProfit)
generate_report("CUSTOM MULTIPLIERS", 'multipliers')


!
! EMISSION CREDITS MODEL
!

! Reset the data
initialize_data

! Remove hard emissions constraints
forall(e in Emiss) do
	EmmissionCS(e) := 0
end-do

!Remove constraints from above
forall(s in Source, t in Times) do
	LongTermCS(s) := 0
	OutputCS(s,t) := Generate(s,t) <= MaxOutput(s)
	DemandCS(t) := EnergySold(t) = Demand(t)
end-do 

LongTermReservoireCS := 0

! Add emissions credit cost to objective
TotalEmissionCreditCost :=
	sum(e in Emiss) (EmissionsGenerated(e) - EmissionsLimit(e)) * EmissionsCreditPrice(e)

TotalProfit := TotalRevenue - TotalRunningCost - TotalIncreaseCost - TotalEmissionCreditCost

maximize(TotalProfit)
generate_report("EMISSIONS MARKET", 'emarket')

!
! Loop over various carbon prices to check the composition of energy generation and profits
!

! Reinstate sulphur limit
EmmissionCS('Sulphur') := EmissionsGenerated('Sulphur') <= EmissionsLimit('Sulphur')

! Reset emission prices to 0
forall(e in Emiss) EmissionsCreditPrice(e) := 0

! Open reporting file
fopen(ReportOutputDir + 'carbon_price_analysis' + '.csv', F_OUTPUT)

write("Profit,TotalRunningCost,TotalIncreaseCost,TotalEmissionCreditCost, Co2Price,")
forall(s in Source) write(s,',')
writeln

repeat
	
	TotalEmissionCreditCost :=	sum(e in Emiss) (EmissionsGenerated(e) - EmissionsLimit(e)) * EmissionsCreditPrice(e)
	TotalProfit := TotalRevenue - TotalRunningCost - TotalIncreaseCost - TotalEmissionCreditCost
	
	maximize(TotalProfit)
	
	write(getsol(TotalProfit),',',
		  getsol(TotalRunningCost),',',
		  getsol(TotalIncreaseCost),',',
		  getsol(TotalEmissionCreditCost),',',
		  EmissionsCreditPrice("CO2"))
	
	forall(s in Source) write(',',getsol(TotalEnergyGenerated(s)))
	writeln
	
	EmissionsCreditPrice("CO2") += 1
until EmissionsCreditPrice("CO2") > 100

fclose(F_OUTPUT)

end-model